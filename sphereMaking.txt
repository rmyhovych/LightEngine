	/*
	const int meridianSize = 25;
	const int parallelSize = 25;
	float* buffer = new float[(parallelSize * meridianSize + 2) * 3];


	float* meridians = new float[meridianSize];
	float* parallels = new float[parallelSize];

	for (int i = 0; i < meridianSize; i++)
	{
		meridians[i] = i * (2 * PI / meridianSize);
	}

	for (int i = 0; i < parallelSize; i++)
	{
		parallels[i] = (i + 1) * (PI / (parallelSize + 1));
	}


	int bCount = 0;
	float* top = new float[3] {0, 1, 0};
	for (int i = 0; i < 3; i++)
	{
		buffer[bCount++] = top[i];
	}
	delete[] top;

	for (int y = 0; y < parallelSize; y++)
	{
		for (int x = 0; x < meridianSize; x++)
		{
			buffer[bCount++] = sin(parallels[y]) * cos(meridians[x]);
			buffer[bCount++] = cos(parallels[y]);
			buffer[bCount++] = sin(parallels[y]) * sin(meridians[x]);
		}
	}

	float* bot = new float[3]{ 0, -1, 0 };
	for (int i = 0; i < 3; i++)
	{
		buffer[bCount++] = bot[i];
	}
	delete[] bot;
	delete[] meridians;
	delete[] parallels;


	GLuint* elements = new GLuint[3 * 2 * (meridianSize) * (parallelSize)];


	int eCount = 0;
	for (int i = 0; i < meridianSize; i++)
	{
		elements[eCount++] = 0;
		elements[eCount++] = (i + 1);
		elements[eCount++] = ((i + 1) % meridianSize) + 1;
	}
	for (int i = 0; i < parallelSize - 1; i++)
	{
		for (int j = 0; j < meridianSize; j++)
		{
			elements[eCount++] = (i * meridianSize + j + 1);
			elements[eCount++] = ((i + 1) * meridianSize + j + 1);
			elements[eCount++] = (((i + 1) * meridianSize) + ((1 + j) % meridianSize) + 1);
			elements[eCount++] = (i * meridianSize + j + 1);
			elements[eCount++] = (((i + 1) * meridianSize) + ((1 + j) % meridianSize) + 1);
			elements[eCount++] = (i * meridianSize + ((j + 1) % meridianSize) + 1);
		}
	}
	int bufferSize = bCount / 3;
	for (int i = bufferSize - meridianSize; i < bufferSize; i++)
	{
		elements[eCount++] = bufferSize - 1;
		elements[eCount++] = (((i - (bufferSize - meridianSize) + 1) % meridianSize) + (bufferSize - meridianSize)) - 1;
		elements[eCount++] = i - 1;
	}


	std::ofstream sphereBuffer("data/sphereBuffer", std::ios::binary);
	sphereBuffer.write((char*)&bCount, sizeof(bCount));
	for (int i = 0; i < bCount; i++)
	{
		sphereBuffer.write((char*)&(buffer[i]), sizeof(float));
	}
	sphereBuffer.close();

	std::ofstream sphereElements("data/sphereElements", std::ios::binary);
	sphereElements.write((char*)&eCount, sizeof(eCount));
	for (int i = 0; i < eCount; i++)
	{
		sphereElements.write((char*)&(elements[i]), sizeof(GLuint));
	}
	sphereElements.close();
	*/
	